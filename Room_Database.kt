Room is a persistence library, part of the Android Jetpack.

Room provides an abstraction layer over SQLite to allow fluent database access while harnessing the full power of SQLite.

Room is now considered as a better approach for data persistence than SQLiteDatabase.
It makes it easier to work with SQLiteDatabase objects in your app, decreasing the amount of boilerplate code
and verifying SQL queries at compile time.


Data from the app can be saved on users’ devices in different ways.
We can store data in the user’s device in SQLite database, shared preferences, Shared storage and App-specific storage.
In this article, we will take a look at saving data, reading, updating, and deleting data in Room Database on Android


WHY USE ROOM?
  
Compile-time verification of SQL queries. each @Query and @Entity is checked at the compile time,
that preserves your app from crash issues at runtime and not only it checks the only syntax, but also missing tables.
Boilerplate code
Easily integrated with other Architecture components (like LiveData)



MAJOR PROBLEMS WITH SQLITE USAGE ARE?

There is no compile-time verification of raw SQL queries. 
For example, if you write a SQL query with a wrong column name that does not exist in real database 
then it will give exception during run time and you can not capture this issue during compile time.

As your schema changes,you need to update the affected SQL queries manually.
This process can be time-consuming and error-prone.

You need to use lots of boilerplate code to convert between SQL queries and Java data objects (POJO).

DIFFERNCES BETWEEN SQLITE AND ROOM

In the case of SQLite, There is no compile-time verification of raw SQLite queries.
But in Room, there is SQL validation at compile time.

You need to use lots of boilerplate code to convert between SQL queries and Java data objects. 
But, Room maps our database objects to Java Object without boilerplate code.

As your schema changes, you need to update the affected SQL queries manually. Room solves this problem.

Room is built to work with LiveData and RxJava for data observation, while SQLite does not.


Room has three main components of Room DB :

Entity
 - Defines schema of database table
 - Represents the table in our database 
 - Annoted with @Entity
Dao
 - Contains methods to access database
 - For every entity a DAO interface is needed that contains functions for accessing the database
 - Annoted with @Dao
Database
- Is the database holder class,that extends the RoomDatabase
- This is an abstract class annoted with the @Database and extending RoomdataBase class.
- Annoted with @Database




ENTITY

Represents a table within the database. 
Room creates a table for each class that has @Entity annotation,
the fields in the class correspond to columns in the table.
Therefore, the entity classes tend to be small model classes that don’t contain any logic.



DAO

DAOs are responsible for defining the methods that access the database. 
In the initial SQLite, we use the Cursor objects. 
With Room, we don’t need all the Cursor related code and can simply define our queries using annotations in the Dao class.
This is the place where we write our queries using annotations in the Dao class..


DATA BASEf

Contains the database holder and serves as the main access point for the underlying connection to your app’s  data.



SQLITE VS ROOM


                SQLITE                                        ROOOM
1.No compile time check of sql querries               |   1. Compile time chack of Sql queries
2.Updating database,changing schema was diififcult    |   2. It is easy to update databse ,and change schema in room with Migration classes
3.Conveting SQL querire to java objects is hard       |   3. Maps database objects to java objects very easily 
and requires too much boiler plate code               |      with little boiler code
4.Cannot work with live data and viewmodel            |   4. Room is built to work with live data and view model


DATABASE

//Inside the database you define all the entities you have inside your database
@Database( entities = arrayOf(User::class), version = 1)

abstract class AppDataBase : RoomDatabase() {
  //

  //For every entitiy you have to have a dao.We use the dao to access the dtabase 
    abstract fun userDao():UserDao



}


ENTITIES

@Entity(tableName="user_table")// Next we have to give our entity a table name
data class User(
  //// This will be our primary key and it will be automaticly generated by the room database
   @PrimaryKey(autoGenerate = true)// Means our room will automaticlay generate our id and increase it.
   //These variable are nothing but the coluns of your table
   @ColumnInfo (name= "first_name")    var firstName:String?      //These are the two ways of describing your tabble names. you can use the one on the variable name or define a custom one usuing the @ColumnInfo                
    @ColumnInfo (name = "last_name")   var lastName:String?
    var surName:String


  
  
  DAO
  
  
  //DAO -Data Access Object
//Contains the methods used for accessing the database.

@Dao
interface UserDao {

    //This is a query for inserting the data
    @Insert( onConflict = OnConflictStrategy.IGNORE)
    suspend fun addUser(user:User)

    //This is a query for reading the data
    @Query("SELECT * FROM user_table ORDER BY id ASC")
    fun readAllData(): LiveData<List<User>>
}












USER

package com.example.tenexapp.data

import android.arch.persistence.room.Dao
import android.arch.persistence.room.Entity
import android.arch.persistence.room.PrimaryKey


@Entity(tableName="user_table")// Next we have to give our entity a table name
data class User(
   @PrimaryKey(autoGenerate = true)// Means our room will automaticlay generate our id and increase it.
    val id:Int,                         // This will be our primary key and it will be automaticly generated by the room database
    val firstName:String,
    val LastName:String,
    val age:Int
)


//Next we have to create our dao interface.


USERDAO

package com.example.tenexapp.data

import android.arch.persistence.room.Dao
import android.arch.persistence.room.Insert
import android.arch.persistence.room.OnConflictStrategy
import android.arch.persistence.room.Query
import androidx.lifecycle.LiveData


//DAO -Data Access Object
//Contains the methods used for accessing the database.

@Dao
interface UserDao {

    //This is a query for inserting the data
    @Insert( onConflict = OnConflictStrategy.IGNORE)
    suspend fun addUser(user:User)

    //This is a query for reading the data
    @Query("SELECT * FROM user_table ORDER BY id ASC")
    fun readAllData(): LiveData<List<User>>
}


USERDATABASE

package com.example.tenexapp.data

import android.arch.persistence.room.Database
import android.arch.persistence.room.RoomDatabase
import android.content.Context


//DATA BASE
//Contains the database holder and serves as the main
// access point for the underlying connection to your app’s  data.


//We need to add abstract infront of this class
//We need to extend the RoomDatabase class
//We need to annotate  this class with the  @DataBase

@Database( entities = [User::class], version = 1, exportSchema = false)
 abstract class UserDataBase:RoomDatabase() {

  abstract fun userDao():UserDao

  companion object {
   @Volatile
   private var INSTANCE:UserDataBase? = null

   fun getDatabase(context: Context) {
    val tempInstance = INSTANCE
    if(tempInstance != null){
     return tempInstance
    }
    synchronized(this){
     val instance
    }
   }


  }



}




 
 



Room Persistence Library
Room Database is now highly recommended for local storage in Android development and one of the android jetpack’s 
  architecture components. It is a wrapper for SQL DB, maps database objects to java objects automatically, 
  and reduces boilerplate code.

It has 3 main components:
1. Database — Abstract class or Singleton
2. Entity (table) — Data class
3. DAO (Database Access Object) — Interface class, it makes queries on the Entity using API.






Add/Edit Employee Detail 
We have an HR Operations app where HR can Add/Update Employee details.
  For this purpose, we will use Room DB to store all employee’s details. I have used a dagger-hilt for dependency injection.

Let’s see step by step how it works with Compose.

Setup Room: Add the below dependencies in your build.gradle file.
  // Room Local DB
    def room_version = "2.4.3"
    implementation "androidx.room:room-runtime:$room_version"
    implementation "androidx.room:room-ktx:$room_version"
    implementation "androidx.compose.runtime:runtime-livedata:1.2.1"
    annotationProcessor "androidx.room:room-compiler:$room_version"
    kapt "androidx.room:room-compiler:$room_version"



Prepare a Table: Make a Data class Employee.kt using annotation Entity. In this example, we have made employees data Entity,
  which represents the employees table in DB, and each variable 
  inside it represents a column inside the table. You can declare column details using the annotation ColumnInfo.


@Parcelize
@Entity(tableName = "employees")
data class Employee(

    @PrimaryKey(autoGenerate = false)
    @NonNull
    @ColumnInfo(name = "id")
    var id: Int,

    @ColumnInfo(name = "employeeId")
    var employeeId: Long,

    @ColumnInfo(name = "employeeName")
    var employeeName: String,

    @ColumnInfo(name = "designation")
    var employeeDesignation: String,

    @ColumnInfo(name = "experience")
    var empExperience: Float,

    @ColumnInfo(name = "email")
    var empEmail: String,

    @ColumnInfo(name = "phoneNo")
    var empPhoneNo: Long
) : Parcelable
  
  
  
  
  Prepare Queries: Make an interface class EmployeeDao.kt and annotate with Dao (Data Access Object). 
  In this class, we need to declare all queries to fetch data from our table. We have annotations available to Insert,
  Update or Delete the record from the table in DB. For others, we need to use Query annotation.
DAO checks for queries on compile time & gives an error if found any.
  
  
  

@Dao
interface EmployeeDao {

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun addEmployee(employee: Employee)

    @Query("SELECT * FROM employees WHERE employeeId = :empId")
    fun findEmployeeById(empId: String): Employee

    @Query("SELECT * FROM employees")
    fun getAllEmployees(): List<Employee>

    @Update
    suspend fun updateEmployeeDetails(employee: Employee)

    @Delete
    suspend fun deleteEmployee(employee: Employee)
}



Create a Room DB: Create an abstract class EmployeeRoomDatabase.kt using the annotation Database and extend RoomDatabase.
  Declare a list of entities, version, etc. EmployeeRoomDatabase 
  class must define an abstract method that has zero arguments and returns an instance of the EmployeeDao class.


  @Database(entities = [(Employee::class)], version = 1, exportSchema = false)
abstract class EmployeeRoomDatabase : RoomDatabase() {

    abstract fun employeeDao(): EmployeeDao

    companion object {
        /*The value of a volatile variable will never be cached, and all writes and reads will be done to and from the main memory.
        This helps make sure the value of INSTANCE is always up-to-date and the same for all execution threads.
        It means that changes made by one thread to INSTANCE are visible to all other threads immediately.*/
        @Volatile
        private var INSTANCE: EmployeeRoomDatabase? = null

        fun getInstance(context: Context): EmployeeRoomDatabase {
            // only one thread of execution at a time can enter this block of code
            synchronized(this) {
                var instance = INSTANCE

                if (instance == null) {
                    instance = Room.databaseBuilder(
                        context.applicationContext,
                        EmployeeRoomDatabase::class.java,
                        "employee_database"
                    ).fallbackToDestructiveMigration()
                        .build()

                    INSTANCE = instance
                }
                return instance
            }
        }
    }
}










Prepare Repository to access DAO: Make a Repository class EmployeeRepository.kt and add our Dao class to the constructor.
  Using the coroutine repository will access Dao to fire a query on the table.
  In the below code, the addEmployee method of employeeDao class is accessed inside a coroutine scope.


class EmployeeRepository(private val employeeDao: EmployeeDao) {

    val allEmployees = MutableLiveData<List<Employee>>()
    val foundEmployee = MutableLiveData<Employee>()
    private val coroutineScope = CoroutineScope(Dispatchers.Main)

    fun addEmployee(newEmployee: Employee) {
        coroutineScope.launch(Dispatchers.IO) {
            employeeDao.addEmployee(newEmployee)
        }
    }

    fun updateEmployeeDetails(newEmployee: Employee) {
        coroutineScope.launch(Dispatchers.IO) {
            employeeDao.updateEmployeeDetails(newEmployee)
        }
    }






Make a ViewModel class HomeViewModel.kt, which will interact with the repository class to get data from DB.



  
  @HiltViewModel
class HomeViewModel @Inject constructor(private val employeeRepository: EmployeeRepository) :
    ViewModel() {

    val employeeList: LiveData<List<Employee>> = employeeRepository.allEmployees

    val foundEmployee: LiveData<Employee> = employeeRepository.foundEmployee
    
    fun getAllEmployees(){
        employeeRepository.getAllEmployees()
    }

    fun addEmployee(employee: Employee) {
        employeeRepository.addEmployee(employee)
        getAllEmployees()
    }

    fun updateEmployeeDetails(employee: Employee) {
        employeeRepository.updateEmployeeDetails(employee)
        getAllEmployees()
    }






Make a function in ComponentActivity: In AddEditEmployeeScreen class, make a function to fire a query & get a result from
      EmployeeRoomDatabase.
      For this purpose, we will use our HomeViewModel class where all methods are already defined.

      
      fun addEmployeeInDB(
    context: Context,
    navController: NavHostController,
    employee: Employee,
    homeViewModel: HomeViewModel
) {
    homeViewModel.addEmployee(employee)
    navController.popBackStack()
}
      
      
      
      
      
      
      
      
      
      
      
      Call the addEmployeeInDB function on the button click and add an employee detail to our DB.
      
            Button(onClick = {
                        if (isEdited) {
                            val employee = Employee(
                                id = if (isEdit) selectedEmployee.id else empId.trim().toInt(),
                                employeeId = empId.trim().toLong(),
                                employeeName = empName,
                                employeeDesignation = empDesignation,
                                empExperience = empExp.toFloat(),
                                empEmail = empEmailId,
                                empPhoneNo = empPhoneNumber.toLong()
                            )
                            if (isEdit) {
                                updateEmployeeInDB(mContext, navController, employee, homeViewModel)
                            } else {
                                addEmployeeInDB(mContext, navController, employee, homeViewModel)
                            }
                            clearAll()
                        }
      
      
      
      
      
      
      
      
      
      
      
      That’s a wrap for now! Many more Jetpack Compose topics to come🔥
You can access the source code from Github.
I hope you find this blog helpful.
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
              Yes, I'm familiar with Room library and how it can be used to store and fetch data in Jetpack Compose.

Room is an SQLite database library that is part of the Android Jetpack library set. It provides an abstraction layer over SQLite and makes it easier to work with databases in Android apps. Room offers compile-time verification of SQL queries, and it allows you to use Kotlin coroutines to perform database operations asynchronously.

To use Room in a Jetpack Compose app, you first need to define your database entities and create a Room database object. An entity is a class that represents a table in your database. You can define properties in the entity class that correspond to columns in the table.

Here's an example of an entity class:

kotlin
Copy code
@Entity(tableName = "users")
data class User(
    @PrimaryKey val id: Int,
    val name: String,
    val age: Int
)
Once you have defined your entities, you can create a Room database object by using the @Database annotation:

kotlin
Copy code
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
The @Database annotation specifies the entities that the database contains and the version of the database. The AppDatabase class extends RoomDatabase, and it provides an abstract method for accessing the DAO (Data Access Object) for the User entity.

The DAO is an interface that defines the database operations that you want to perform. You can define methods in the DAO for inserting, updating, and querying the database. Here's an example of a DAO:

kotlin
Copy code
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsers(): List<User>

    @Insert
    fun insertUser(user: User)

    @Update
    fun updateUser(user: User)

    @Delete
    fun deleteUser(user: User)
}
In this DAO, there are methods for getting all users, inserting a user, updating a user, and deleting a user.

To use Room in your Jetpack Compose app, you can create a ViewModel that retrieves data from the database and exposes it to the UI. You can then use remember to create a stateful object that retains the data across recompositions. For example:

kotlin
Copy code
class UserViewModel(application: Application) : AndroidViewModel(application) {
    private val userDao = AppDatabase.getInstance(application).userDao()
    val allUsers = userDao.getAllUsers()
}

@Composable
fun UserList(viewModel: UserViewModel = viewModel()) {
    val users by remember { viewModel.allUsers }.observeAsState()
    // Render the list of users
}
In this example, the UserViewModel retrieves the User data from the AppDatabase and exposes it as a LiveData object. The UserList composable function uses remember to create a stateful object that retains the data across recompositions. The observeAsState function observes changes to the LiveData object and updates the UI when the data changes.
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      





