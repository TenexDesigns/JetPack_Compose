Room is a persistence library, part of the Android Jetpack.

Room provides an abstraction layer over SQLite to allow fluent database access while harnessing the full power of SQLite.

Room is now considered as a better approach for data persistence than SQLiteDatabase.
It makes it easier to work with SQLiteDatabase objects in your app, decreasing the amount of boilerplate code
and verifying SQL queries at compile time.


Data from the app can be saved on users’ devices in different ways.
We can store data in the user’s device in SQLite database, shared preferences, Shared storage and App-specific storage.
In this article, we will take a look at saving data, reading, updating, and deleting data in Room Database on Android


WHY USE ROOM?
  
Compile-time verification of SQL queries. each @Query and @Entity is checked at the compile time,
that preserves your app from crash issues at runtime and not only it checks the only syntax, but also missing tables.
Boilerplate code
Easily integrated with other Architecture components (like LiveData)



MAJOR PROBLEMS WITH SQLITE USAGE ARE?

There is no compile-time verification of raw SQL queries. 
For example, if you write a SQL query with a wrong column name that does not exist in real database 
then it will give exception during run time and you can not capture this issue during compile time.

As your schema changes,you need to update the affected SQL queries manually.
This process can be time-consuming and error-prone.

You need to use lots of boilerplate code to convert between SQL queries and Java data objects (POJO).

DIFFERNCES BETWEEN SQLITE AND ROOM

In the case of SQLite, There is no compile-time verification of raw SQLite queries.
But in Room, there is SQL validation at compile time.

You need to use lots of boilerplate code to convert between SQL queries and Java data objects. 
But, Room maps our database objects to Java Object without boilerplate code.

As your schema changes, you need to update the affected SQL queries manually. Room solves this problem.

Room is built to work with LiveData and RxJava for data observation, while SQLite does not.


Room has three main components of Room DB :

Entity
Dao
Database




ENTITY

Represents a table within the database. 
Room creates a table for each class that has @Entity annotation,
the fields in the class correspond to columns in the table.
Therefore, the entity classes tend to be small model classes that don’t contain any logic.



DAO

DAOs are responsible for defining the methods that access the database. 
In the initial SQLite, we use the Cursor objects. 
With Room, we don’t need all the Cursor related code and can simply define our queries using annotations in the Dao class.
This is the place where we write our queries using annotations in the Dao class..


DATA BASE

Contains the database holder and serves as the main access point for the underlying connection to your app’s  data.
























USER

package com.example.tenexapp.data

import android.arch.persistence.room.Dao
import android.arch.persistence.room.Entity
import android.arch.persistence.room.PrimaryKey


@Entity(tableName="user_table")// Next we have to give our entity a table name
data class User(
   @PrimaryKey(autoGenerate = true)// Means our room will automaticlay generate our id and increase it.
    val id:Int,                         // This will be our primary key and it will be automaticly generated by the room database
    val firstName:String,
    val LastName:String,
    val age:Int
)


//Next we have to create our dao interface.


USERDAO

package com.example.tenexapp.data

import android.arch.persistence.room.Dao
import android.arch.persistence.room.Insert
import android.arch.persistence.room.OnConflictStrategy
import android.arch.persistence.room.Query
import androidx.lifecycle.LiveData


//DAO -Data Access Object
//Contains the methods used for accessing the database.

@Dao
interface UserDao {

    //This is a query for inserting the data
    @Insert( onConflict = OnConflictStrategy.IGNORE)
    suspend fun addUser(user:User)

    //This is a query for reading the data
    @Query("SELECT * FROM user_table ORDER BY id ASC")
    fun readAllData(): LiveData<List<User>>
}


USERDATABASE

package com.example.tenexapp.data

import android.arch.persistence.room.Database
import android.arch.persistence.room.RoomDatabase
import android.content.Context


//DATA BASE
//Contains the database holder and serves as the main
// access point for the underlying connection to your app’s  data.


//We need to add abstract infront of this class
//We need to extend the RoomDatabase class
//We need to annotate  this class with the  @DataBase

@Database( entities = [User::class], version = 1, exportSchema = false)
 abstract class UserDataBase:RoomDatabase() {

  abstract fun userDao():UserDao

  companion object {
   @Volatile
   private var INSTANCE:UserDataBase? = null

   fun getDatabase(context: Context) {
    val tempInstance = INSTANCE
    if(tempInstance != null){
     return tempInstance
    }
    synchronized(this){
     val instance
    }
   }


  }



}










